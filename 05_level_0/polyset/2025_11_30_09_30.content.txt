===============================================
UPDATED AT 2025_11_30_09_30
===============================================

===============================================
DIRECTORY TREE STRUCTURE
===============================================

.
├── 2025_11_30_09_30.content.txt
├── array_bag.cpp
├── array_bag.hpp
├── bag.hpp
├── gen_context.sh
├── main.cpp
├── polyset.subject.txt
├── searchable_array_bag.cpp
├── searchable_array_bag.hpp
├── searchable_bag.hpp
├── searchable_tree_bag.cpp
├── searchable_tree_bag.hpp
├── set.cpp
├── set.hpp
├── subject
│   ├── array_bag.cpp
│   ├── array_bag.hpp
│   ├── bag.hpp
│   ├── main.cpp
│   ├── polyset.subject.txt
│   ├── searchable_bag.hpp
│   ├── tree_bag.cpp
│   └── tree_bag.hpp
├── tree_bag.cpp
└── tree_bag.hpp

1 directory, 24 files


===============================================
RECURSIVE FILE LISTING (ls -laR)
===============================================

.:
total 68
drwxr-xr-x 3 fcatala- 2022_barcelona 4096 Nov 30 09:30 .
drwxr-xr-x 5 fcatala- 2022_barcelona   49 Nov  1 05:33 ..
-rw-r--r-- 1 fcatala- 2022_barcelona 1104 Nov 30 09:30 2025_11_30_09_30.content.txt
-rw-r--r-- 1 fcatala- 2022_barcelona 1383 Nov 29 14:16 array_bag.cpp
-rw-r--r-- 1 fcatala- 2022_barcelona  310 Nov 29 14:43 array_bag.hpp
-rw-r--r-- 1 fcatala- 2022_barcelona  168 Nov 29 13:29 bag.hpp
-rwxr-xr-x 1 fcatala- 2022_barcelona 3461 Nov 30 09:29 gen_context.sh
-rw-r--r-- 1 fcatala- 2022_barcelona 2692 Nov 30 09:15 main.cpp
-rw-r--r-- 1 fcatala- 2022_barcelona 1088 Nov 30 08:21 polyset.subject.txt
-rw-r--r-- 1 fcatala- 2022_barcelona 1459 Nov 29 15:19 searchable_array_bag.cpp
-rw-r--r-- 1 fcatala- 2022_barcelona 1262 Nov 30 08:46 searchable_array_bag.hpp
-rw-r--r-- 1 fcatala- 2022_barcelona  123 Nov 30 07:28 searchable_bag.hpp
-rw-r--r-- 1 fcatala- 2022_barcelona 1572 Nov 29 18:15 searchable_tree_bag.cpp
-rw-r--r-- 1 fcatala- 2022_barcelona 1251 Nov 30 08:46 searchable_tree_bag.hpp
-rw-r--r-- 1 fcatala- 2022_barcelona 1289 Nov 30 07:27 set.cpp
-rw-r--r-- 1 fcatala- 2022_barcelona 1308 Nov 30 07:27 set.hpp
drwxr-xr-x 2 fcatala- 2022_barcelona  172 Nov 30 07:34 subject
-rw-r--r-- 1 fcatala- 2022_barcelona 2314 Nov 30 07:16 tree_bag.cpp
-rw-r--r-- 1 fcatala- 2022_barcelona  564 Nov 29 16:07 tree_bag.hpp

./subject:
total 36
drwxr-xr-x 2 fcatala- 2022_barcelona  172 Nov 30 07:34 .
drwxr-xr-x 3 fcatala- 2022_barcelona 4096 Nov 30 09:30 ..
-rw-r--r-- 1 fcatala- 2022_barcelona 1383 Oct 28 16:35 array_bag.cpp
-rw-r--r-- 1 fcatala- 2022_barcelona  310 Oct 28 16:35 array_bag.hpp
-rw-r--r-- 1 fcatala- 2022_barcelona  168 Oct 28 16:35 bag.hpp
-rw-r--r-- 1 fcatala- 2022_barcelona 1122 Oct 28 16:35 main.cpp
-rw-r--r-- 1 fcatala- 2022_barcelona 1088 Oct 28 16:35 polyset.subject.txt
-rw-r--r-- 1 fcatala- 2022_barcelona  123 Oct 28 16:35 searchable_bag.hpp
-rw-r--r-- 1 fcatala- 2022_barcelona 2310 Oct 28 16:35 tree_bag.cpp
-rw-r--r-- 1 fcatala- 2022_barcelona  564 Oct 28 16:35 tree_bag.hpp


===============================================
FILE CONTENTS
===============================================

-----------------------------------------------
File: ./array_bag.cpp
-----------------------------------------------
#include "array_bag.hpp"
#include <iostream>

array_bag::array_bag() {
  size = 0;
  data = nullptr;
}

array_bag::array_bag(const array_bag &src) {
  size = src.size;
  data = new int[size];
  for (int i = 0; i < size; i++) {
	data[i] = src.data[i];
  }
}

array_bag &array_bag::operator=(const array_bag &src) {
	if (this != &src) {
		if (data != nullptr) {
			delete[] data;
			data = nullptr;
		}
		size = src.size;
		data = new int[size];
		for (int i = 0; i < size; i++) {
			data[i] = src.data[i];
		}
	}
	return *this;
}

array_bag::~array_bag() {
	if (data != nullptr) {
		delete[] data;
		data = nullptr;
	}
}

void array_bag::insert(int item) {
	int *new_data = new int[size + 1];
	for (int i = 0; i < size; i++) {
		new_data[i] = data[i];
	}
	new_data[size] = item;
	if (data != nullptr) {
		delete[] data;
	}
	data = new_data;
	size++;
}

void array_bag::insert(int *items, int count) {
	int *new_data = new int[size + count];
	for (int i = 0; i < size; i++) {
		new_data[i] = data[i];
	}
	for (int i = 0; i < count; i++) {
		new_data[size + i] = items[i];
	}
	if (data != nullptr) {
		delete[] data;
	}
	data = new_data;
	size += count;
}

void array_bag::print() const {
	for (int i = 0; i < size; i++) {
		std::cout << data[i] << " ";
	}
	std::cout << std::endl;
}

void array_bag::clear() {
	if (data != nullptr) {
		delete[] data;
		data = nullptr;
	}
	size = 0;
}


-----------------------------------------------
File: ./array_bag.hpp
-----------------------------------------------
#pragma once

#include "bag.hpp"

class array_bag : virtual public bag
{
 protected:
	int *data;
	int size;

 public:
	array_bag();
	array_bag(const array_bag &);
	array_bag &operator=(const array_bag &other);
	~array_bag();

	void insert(int);
	void insert(int *, int);
	void print() const;
	void clear();
};


-----------------------------------------------
File: ./bag.hpp
-----------------------------------------------
#pragma once

class bag {
public:
	virtual void insert (int) = 0;
	virtual void insert (int *, int) = 0;
	virtual void print() const = 0;
	virtual void clear() = 0;
};


-----------------------------------------------
File: ./main.cpp
-----------------------------------------------
#include "searchable_bag.hpp"
#include <cstdlib>
#include "searchable_array_bag.hpp"
#include "searchable_tree_bag.hpp"
#include "set.hpp"
#include <iostream>

int main(int argc, char **argv) {
  if (argc == 1)
    return 1;
  searchable_bag *t = new searchable_tree_bag;
  searchable_bag *a = new searchable_array_bag;
  for (int i = 1; i < argc; i++) {
    t->insert(atoi(argv[i]));
    a->insert(atoi(argv[i]));
  }
  std::cout << "The tree :\n";
  t->print();
  std::cout << "The array :\n";
  a->print();

  for (int i = 1; i < argc; i++) {
	int val = atoi(argv[i]);
	std::cout << "At tree we should get 1 => " << t->has(atoi(argv[i])) << std::endl;
    std::cout << "At array we should get 1 => " << a->has(atoi(argv[i])) << std::endl;
    std::cout << "At tree for " << val -1 << " we get => " << t->has(atoi(argv[i]) - 1) << std::endl;
    std::cout << "At array we get => " << a->has(atoi(argv[i]) - 1) << std::endl;
  }

  t->clear();
//  a->clear();

  std::cout << "Casting\n";
  const searchable_array_bag tmp(static_cast<searchable_array_bag &>(*a));
  a->print();
  tmp.print();
  tmp.has(1);
  a->clear();
  std::cout << "NOTHING up?\n";
  {
	  std::cout << "New block testing casting\n";
	  for (int i = 1; i < argc; i++) 
	  {
		  //t->insert(atoi(argv[i]));
		  a->insert(atoi(argv[i]));
	  }
	  //t->print();
	  a->print();
	  const searchable_array_bag tmp_bis(static_cast<searchable_array_bag &>(*a));
	  tmp_bis.print();
	  std::cout << "1 is in tmp_bis (1 = true) "<< tmp_bis.has(1) << std::endl;
	  a->clear();
	  std::cout << "END OF New block testing casting\n";
  }

  set sa(*a);
  set st(*t);
  for (int i = 1; i < argc; i++) {
    st.insert(atoi(argv[i]));
    sa.insert(atoi(argv[i]));
    //std::cout << "Should be 1 " << sa.has(atoi(argv[i])) << std::endl;
	std::cout << "Printing " << i << " values of sa (2 times) and st (once)\n"; 
	sa.print();   
	sa.get_bag().print();
    st.print();
    
	sa.clear();
    sa.insert(
        (int[]){
            1,
            2,
            3,
            4,
        },
        4);
    std::cout << std::endl;
  }
  std::cout << "Another testing (inserting odd nums from args after 1, 8, 7, 0)\n";
  sa.clear();
  st.clear();
  sa.insert((int[]){1, 8, 7, 0, 69}, 4);
  st.insert((int[]){1, 8, 7, 0, 69}, 4);
  int val;
  for (int i = 1; i < argc; ++i)
  {
	  val = atoi(argv[i]);
	  if (i % 2)
	  {
		  st.insert(val);
		  sa.insert(val);
	  }
  }
  std::cout << "The array :\n";
  sa.print();
  std::cout << "The tree :\n";
  st.print();
  // Added to the given main to avoid leaks
  delete static_cast<searchable_tree_bag*>(t);
  delete static_cast<searchable_array_bag*>(a);
  // End of the addition
  return 0;
}


-----------------------------------------------
File: ./polyset.subject.txt
-----------------------------------------------
Assigment name: Polyset
Expected File: searchable_array_bag.cpp, searchable_array_bag.hpp,
searchable_tree_bg.cpp, searchable_tree_bag.hpp, set.cpp, set.hpp

You will find in this directory some classes:
- bag: an abstract class representing a bag
- searchable_bag: an abstract class representing a bag with the ability to
	search in it.
- array_bag: an implementation of a bag with an array an underlying data
	structure.
- tree_bag: an implementation of a bag with a binary search tree as underlying
	data structure.

If you don't know what is a set or a bag (shame!) you can read the attached
file shame.en.txt

First Part:
Since a bag without a searching function isn't very useful, implement two
classes searchable_array_bag and searchable_tree_bag, that will inherit from
array_bag and tree_bag and implement the searchable bag abstract class.

Second Part:
Implement the class set that will wrap a searchable_bag and turn it into a set.
You will find in this dir a main that must compile with your code.
All classes should be under orthodox canonical form. Don't forget the const.


-----------------------------------------------
File: ./searchable_array_bag.cpp
-----------------------------------------------
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   searchable_array_bag.cpp                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: fcatala- <fcatala-@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/29 13:48:20 by fcatala-          #+#    #+#             */
/*   Updated: 2025/11/29 14:53:05 by fcatala-         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "searchable_array_bag.hpp"

searchable_array_bag::searchable_array_bag(){}

searchable_array_bag::~searchable_array_bag()
{
}

searchable_array_bag::searchable_array_bag(const searchable_array_bag& other): array_bag(other)
{
}

searchable_array_bag& searchable_array_bag::operator=(const searchable_array_bag& other)
{
	if (this != &other)
	{
		array_bag::operator=(other);
	}
	return (*this);
}

bool searchable_array_bag::has(int n) const
{
	for (int i = 0; i < this->size; ++i)
	{
		if (this->data[i] == n)
		{
			return (true);
		}
	}
	return (false);
}


-----------------------------------------------
File: ./searchable_array_bag.hpp
-----------------------------------------------
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   searchable_array_bag.hpp                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: fcatala- <fcatala-@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/29 13:38:11 by fcatala-          #+#    #+#             */
/*   Updated: 2025/11/30 08:45:05 by fcatala-         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#pragma once

#include "array_bag.hpp"
#include "searchable_bag.hpp"

class searchable_array_bag : public array_bag, public searchable_bag
{
	public:
		searchable_array_bag();
		virtual ~searchable_array_bag();
		searchable_array_bag(const searchable_array_bag& other);
		searchable_array_bag& operator=(const searchable_array_bag& other);
		bool has(int n) const;
};
	


-----------------------------------------------
File: ./searchable_bag.hpp
-----------------------------------------------
#pragma once

#include "bag.hpp"

class searchable_bag : virtual public bag {
public:
	virtual bool has(int) const = 0;
};


-----------------------------------------------
File: ./searchable_tree_bag.cpp
-----------------------------------------------
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   searchable_tree_bag.cpp                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: fcatala- <fcatala-@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/29 15:24:05 by fcatala-          #+#    #+#             */
/*   Updated: 2025/11/29 17:59:14 by fcatala-         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "searchable_tree_bag.hpp"
#include <iostream>

searchable_tree_bag::searchable_tree_bag(){}

searchable_tree_bag::~searchable_tree_bag(){}

searchable_tree_bag::searchable_tree_bag(const searchable_tree_bag& other) : tree_bag(other)
{}

searchable_tree_bag& searchable_tree_bag::operator=(const searchable_tree_bag& other)
{
	if (this != &other)
	{
		tree_bag::operator=(other);
	}
	return(*this);
}

bool searchable_tree_bag::has(int n) const
{
	node *current = this->tree;
	while (current)
	{
		if (current->value == n)
		{
			return (true);
		}
		if (current->value < n)
		{
			current = current->r;
		}
		else
		{
			current = current->l;
		}
	}
	return (false);
}




-----------------------------------------------
File: ./searchable_tree_bag.hpp
-----------------------------------------------
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   searchable_tree_bag.hpp                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: fcatala- <fcatala-@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/29 15:20:37 by fcatala-          #+#    #+#             */
/*   Updated: 2025/11/30 08:44:28 by fcatala-         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#pragma once

#include "tree_bag.hpp"
#include "searchable_bag.hpp"

class searchable_tree_bag : public tree_bag, public searchable_bag
{
	public:
		searchable_tree_bag();
		virtual ~searchable_tree_bag();
		searchable_tree_bag(const searchable_tree_bag& other);
		searchable_tree_bag& operator=(const searchable_tree_bag& other);
		bool has(int n) const;
};


-----------------------------------------------
File: ./set.cpp
-----------------------------------------------
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   set.cpp                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: fcatala- <fcatala-@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/30 05:18:32 by fcatala-          #+#    #+#             */
/*   Updated: 2025/11/30 06:59:14 by fcatala-         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "set.hpp"

set::~set(){}

set::set(searchable_bag &other) : m_bag(other) {}

const searchable_bag& set::get_bag()
{
	return (m_bag);
}

void set::insert(int n)
{
	m_bag.insert(n);
}

void set::insert(int *c, int count)
{
	m_bag.insert(c, count);
}


bool set::has(int n) const
{
	return(m_bag.has(n));
}

void set::print() const
{
	m_bag.print();
}

void set::clear()
{
	m_bag.clear();
}


-----------------------------------------------
File: ./set.hpp
-----------------------------------------------
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   set.hpp                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: fcatala- <fcatala-@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/30 05:17:53 by fcatala-          #+#    #+#             */
/*   Updated: 2025/11/30 06:58:05 by fcatala-         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#pragma once

#include "bag.hpp"
#include "searchable_bag.hpp"

class set
{
	private:
		searchable_bag&	m_bag;
	public:
		set() = delete;
		~set();
		set(const set &other) = delete;
		set& operator=(const set &other) = delete;
		set(searchable_bag &other);
		const searchable_bag& get_bag();
		void insert(int n);
		void insert(int *c, int count);
		bool has(int n) const;
		void print() const;
		void clear();
};




-----------------------------------------------
File: ./tree_bag.cpp
-----------------------------------------------
#include "tree_bag.hpp"
#include <iostream>

tree_bag::tree_bag() {
	tree = nullptr;
}

tree_bag::tree_bag(const tree_bag &src) {
	tree = copy_node(src.tree);
}

tree_bag::~tree_bag() {
	destroy_tree(tree);
}

tree_bag &tree_bag::operator=(const tree_bag &src) {
	if (this != &src) {
		destroy_tree(tree);
		tree = copy_node(src.tree);
	}
	return *this;
}

tree_bag::node *tree_bag::extract_tree() {
	node *temp = tree;
	tree = nullptr;
	return temp;
}

void tree_bag::set_tree(node *new_tree) {
	destroy_tree(tree);
	tree = new_tree;
}

void tree_bag::insert(int item) {
	node *new_node = new node;
	// alloc new node
	std::cout << "create node: " << item << std::endl;
	new_node->value = item;
	new_node->l = nullptr;
	new_node->r = nullptr;

	if (tree == nullptr) {
		// std::cout << "tree is null - adding" << std::endl;
		tree = new_node;
	} 
	else {
		node *current = tree;
		while (true) {
			if (item < current->value) {
				if (current->l == nullptr) {
					current->l = new_node;
					break;
				} else {
					current = current->l;
				}
			} else if (item > current->value) {
				if (current->r == nullptr) {
					current->r = new_node;
					break;
				} else {
					current = current->r;
				}
			} else {
				std::cout << "duplicate value: delete node" << std::endl;
				delete new_node;
				break;
			}
		}
	}
}

void tree_bag::insert(int *items, int count) {
	for (int i = 0; i < count; i++) {
		insert(items[i]);
	}
}

void tree_bag::print() const {
	print_node(tree);
	std::cout << std::endl;
}

void tree_bag::clear() {
	destroy_tree(tree);
	tree = nullptr;
}

// defined as static functions in the class
void tree_bag::destroy_tree(node *current) {
	if (current != nullptr) {
		std::cout << "destroying value: " << current->value << std::endl;
		destroy_tree(current->l);
		destroy_tree(current->r);
		delete current;
	}
}

void tree_bag::print_node(node *current) {
	if (current != nullptr) {
		print_node(current->l);
		//if (current->value != 0)
			std::cout << current->value << " ";
		print_node(current->r);
	}
}

tree_bag::node *tree_bag::copy_node(node *current) {
	if (current == nullptr) {
		return nullptr;
	} else {
		node *new_node = new node;
		new_node->value = current->value;
		new_node->l = copy_node(current->l);
		new_node->r = copy_node(current->r);
		return new_node;
	}
}


-----------------------------------------------
File: ./tree_bag.hpp
-----------------------------------------------
#pragma once

#include "bag.hpp"

class tree_bag : virtual public bag {
protected:
  struct node {
    node *l;
    node *r;
    int value;
  };
  node *tree;

public:
  tree_bag();
  tree_bag(const tree_bag &);
  tree_bag  &operator=(const tree_bag &);
  ~tree_bag();

  node *extract_tree();
  void set_tree(node *);

  virtual void insert(int);
  virtual void insert(int *array, int size);
  virtual void print() const;
  virtual void clear();

private:
  static void destroy_tree(node *);
  static void print_node(node *);
  static node *copy_node(node *);
};


